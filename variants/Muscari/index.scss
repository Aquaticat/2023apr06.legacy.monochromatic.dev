/*
 * IntelliJ Platform bug, false positive of "Mismatched property value" when using colors for border-block/inline.
 *
 * The design right now is horrible.
 * Maybe I really should have designed in Figma first.
 *
 * Also not using the :has() selector right now because Firefox doesn't fully support it and doesn't enable it by default.
 * Considering using it anyways because every other browser has support and [We plan to work on this in the first half of this year](https://bugzilla.mozilla.org/show_bug.cgi?id=418039#c62).
 */

:root {
  @media (prefers-color-scheme: dark) {
    --foreground: white;
    --background: black;
  }
  @media (prefers-color-scheme: light) {
    --foreground: black;
    --background: white;
  }

  * + {
    section {
      margin-block-start: 3rem;
    }

    :is(ol,ul) {
      margin-block-start: 1.75rem;
    }
  }

  li :is(ol,ul) {
    margin-block-start: 0.4rem;
    line-height: 1.3;
  }

  :is(h1,h2,h3,h4,h5) {
    + section {
      margin-block-start: 1rem;
    }
  }
}

x-wrapper {
  display: block;

  // FIXME: Still couldn't figure out a pure CSS solution for toggling themes.
  color-scheme: light dark;
}

* {
  box-sizing: border-box;

  margin-block: 0;
}

html {
  // FIXedME: HTML and body has space in between?
  //          Update: Got it. <main>'s margin-block caused it.
  //          Next time consider using * { border:1px solid red; } to debug.
  color: var(--foreground);
  background-color: var(--background);
  font-family: sans-serif;
  letter-spacing: 0.1ch;
  line-height: 1.5;
}

body {
  margin-inline: 0;
}

header {
  color: white;
  background-color: black;
  padding-block: 5rem;
  border-block-end: var(--foreground) solid 0.5rem;

  // FIXME: Why would setting font-size would cause the <p> to take the whole width?
  //        Setting font-size: 2rem; inside > hgroup or inside > hgroup > * causes the same issue.
  //        Whatever, I'll just change <p>'s font-size inside by hand for now.
  // font-size: 2em;
  > hgroup {
    text-align: unset;

    > h1 {
      text-align: unset;

      + p {
        font-size: clamp(1.25rem, 1.75rem, 2vw);
        transform: translateX(0.1ch);
      }
    }
  }
}

hgroup {
  max-inline-size: 60ch;
  box-sizing: content-box;
  padding-inline: 8vw;
  margin-inline: auto;
  text-align: center;

  > :is(h1,h2,h3,h4,h5,h6) {
    line-height: unset;
    margin-block-end: clamp(0.2rem, 0.5rem, 1vw);
  }
}

main {
  max-inline-size: 90ch;
  box-sizing: content-box;
  margin-inline: auto;
  padding-inline: 4ch;
  margin-block: clamp(1.75rem, 4rem, 5vw);

  * + * {
    margin-block-start: 1rem;
  }
}

h1 {
  line-height: 2;
  font-size: clamp(2.5rem, 4rem, 8vw);
  font-weight: 900;
  text-align: center;
  margin-block-end: clamp(2rem, 4rem, 5vw);

  /**
   * Solution for font width greater than container width problem.
   *
   * Taken from https://stackoverflow.com/a/32570813 CC BY-SA 3.0
   * which credited https://stackoverflow.com/a/20249560/5061744 CC BY-SA 3.0
   *
   * Update: Problem not solved. (Why?)
   * Decided to use Mono<hromᴧti< as content to give the illusion that it's centered.
   */
  // &::after {
  //   display: block;
  //   content: attr(data-content);
  //   font-weight: 900;
  //   color: transparent;
  //   height: 1px;
  //   white-space: nowrap;
  //   overflow: hidden;
  //   visibility: hidden;
  // }
}

h2 {
  line-height: 2;
  font-size: clamp(1.75rem, 2.5rem, 6vw);
  text-align: center;
}

h3 {
  line-height: 1.75;
  font-size: clamp(1.2rem, 1.5rem, 4vw);
}

h4 {
  line-height: 1.25;
  font-size: clamp(1rem, 1.25rem, 3vw);
  font-weight: normal;
}

h5 {
  font-size: clamp(0.9rem, 1.1rem, 2.5vw);
}


hr {
  height: 1rem;
  border-inline: none;
  border-block: 0.25rem solid var(--foreground);
  margin-block: clamp(0.75rem, 3rem, 5vw);
  text-align: center;
  inline-size: calc(100% + 2rem);
  transform: translateX(-1rem);

  // TODO: Add § decoration.

  overflow: visible;

  &::after {
    content: '§';
    color: var(--foreground);
    font-size: 1.75rem;
    font-weight: bold;
    background-color: var(--background);
    padding-inline: 0.5rem;
    position: relative;
    top: -1.25rem;
  }
}

/**
 * FIXME: Still haven't figured out how to prevent flexbox from changing sizes when opening and closing <detail>.
 */
summary {
  margin-block-end: 1.5rem;
  outline: none;
  display: flex;
  flex: {
    wrap: nowrap;
  }
  column-gap: 1em;
  align-items: center;
  inline-size: calc(100% + 2rem);
  transform: translateX(-1rem);
  padding-inline: 1rem;
  padding-block: 0.5rem;
  border: {
    style: solid;
    color: var(--foreground);
    // noinspection CssInvalidPropertyValue
    inline-start-color: var(--background);
    width: 0.25rem;
  }

  &:has(h2) {
    // FIXME: Somehow, using box-sizing: content-box and more translateX to achieve a "wider than content" appearance
    //        would cause it to overflow (hidden) when vw is small?
    // box-sizing: content-box;
    border-width: 0.5rem;
  }

  &:has(h4) {
    border-block-end-color: var(--background);
    padding-block: 0.25rem;
    inline-size: calc(100% + 0.5rem);
    transform: translateX(-0.25rem);
  }

  &:has(h5) {
    border-block-color: var(--background);
    padding-block: 0;
    inline-size: calc(100% + 0.25rem);
    transform: translateX(-0.125rem);
  }

  // TODO: Add ::before for #, getting the link to the section.

  > :is(h2,h3) {
    flex-grow: 99;
  }

  + * {
    margin-block-start: 0;
  }
}

details {
  + details {
    margin-block-start: clamp(2.5rem, 3rem, 6vw);
  }

  > summary {
    &::after {
      margin-right: 0.875rem;
      content: '>';
      transform: translateY(0.05em);
      font-size: 2em;
    }
  }

  &[open] {
    > summary {
      // noinspection CssInvalidPropertyValue
      border: {
        inline-start-color: var(--foreground);
        block-end-color: var(--background);
      }

      &::after {
        content: 'Λ';
        transform: translateY(0.04em);
        font-size: 1.6em;
      }
    }
  }
}

:is(ol,ul) {
  padding-inline-start: 2ch;

  + * {
    margin-block-start: 1.5em;
  }
}

li {
  * + * {
    margin-block-start: 0.5rem;
  }

  + li {
    margin-block-start: 1.25rem;
  }

  li + li {
    margin-block-start: 0.75rem;
  }

  > {
    ol > li {
      list-style-type: upper-roman;
    }

    ul > li {
      list-style-type: square;
    }
  }
}

section + * {
  margin-block-start: 2rem;
}

a {
  color: var(--foreground);
  text-underline-offset: 0.5ex;

  &:focus,
  &:hover,
  &:active {
    font-size: unset;
    color: var(--background);
    background-color: var(--foreground);
    box-shadow: 0.2ch 0 0 0 var(--foreground),
    -0.2ch 0 0 0 var(--foreground),
    0 0.2ex 0 0 var(--foreground),
    0 -0.2ex 0 0 var(--foreground),
    0.2ch 0.2ex 0 0 var(--foreground),
    -0.2ch 0.2ex 0 0 var(--foreground),
    0.2ch -0.2ex 0 0 var(--foreground),
    -0.2ch -0.2ex 0 0 var(--foreground);

    text-shadow: -0.01ch 0 0 var(--background),
    0.01ch 0 0 var(--background),
    0 0.01ex 0 var(--background),
    0 -0.01ex 0 var(--background);
  }
}

:is(pre,code) {
  font-family: 'Source Code Pro', 'SF Mono', Monaco, Inconsolata, 'Fira Mono', 'Droid Sans Mono', monospace, monospace;
}

.ul_direction_inlineStart {
  display: flex;
  flex: {
    direction: row;
    wrap: wrap;
  }
  row-gap: 1em;
  column-gap: 2em;
  align-items: baseline;

  > * + * {
    margin-block-start: 0;
  }
}


label {
  &.button_importance_tertiary {
    background-color: black;
    text-transform: uppercase;
    font-family: 'Source Code Pro', 'SF Mono', Monaco, Inconsolata, 'Fira Mono', 'Droid Sans Mono', monospace;
    font-weight: bold;
    padding-block: clamp(0.3em, 0.4em, 1vw);
    padding-inline: clamp(0.5em, 0.75em, 1.5vw);
    border-color: white;
    border-style: solid;
    border-width: 0.2em;
    font-size: clamp(1em, 1.2em, 2.5vw);

    &:focus,
    &:hover,
    &:active {
      color: black;
      background-color: white;
      font-weight: 900;

    }

    input {
      visibility: hidden;
      position: absolute;
      left: -9999;
    }
  }
}

#colorSchemeToggle {
  position: absolute;
  right: 0;
  top: 0;
  display: flex;

  &::after {
    content: '= theme';
  }

  &:focus,
  &:hover,
  &:active {
    &::after {
      content: '\00a0!theme';
    }
  }

  &::before {
    font-size: 1.5em;
    content: '☉';
    height: 1em;
    width: 1em;
    transform: translate(-0.2ch, -0.45ex);
  }

  &:has(input[type='checkbox']:checked)::before {
    font-size: 1.4em;
    content: '☽';
    transform: translate(0, -0.4ex);
  }
}
